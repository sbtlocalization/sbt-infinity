// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

package parser

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
	"io"
)


/**
 * InterPlay ACM audio codec format. Used by Infinity Engine games for compressed audio.
 * The header is followed by a compressed bitstream that must be decoded algorithmically
 * using a subband decoder.
 * @see <a href="https://gibberlings3.github.io/iesdp/file_formats/ie_formats/acm.htm
 * ">Source</a>
 */
type Acm struct {
	Signature []byte
	NumSamples uint32
	NumChannels uint16
	SampleRate uint16
	SubbandParams uint16
	_io *kaitai.Stream
	_root *Acm
	_parent kaitai.Struct
	_f_blockSize bool
	blockSize int
	_f_compressedData bool
	compressedData []byte
	_f_levels bool
	levels int
	_f_subBlocks bool
	subBlocks int
}
func NewAcm() *Acm {
	return &Acm{
	}
}

func (this Acm) IO_() *kaitai.Stream {
	return this._io
}

func (this *Acm) Read(io *kaitai.Stream, parent kaitai.Struct, root *Acm) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.Signature = tmp1
	if !(bytes.Equal(this.Signature, []uint8{151, 40, 3, 1})) {
		return kaitai.NewValidationNotEqualError([]uint8{151, 40, 3, 1}, this.Signature, this._io, "/seq/0")
	}
	tmp2, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumSamples = uint32(tmp2)
	tmp3, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.NumChannels = uint16(tmp3)
	tmp4, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SampleRate = uint16(tmp4)
	tmp5, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SubbandParams = uint16(tmp5)
	return err
}
func (this *Acm) BlockSize() (v int, err error) {
	if (this._f_blockSize) {
		return this.blockSize, nil
	}
	this._f_blockSize = true
	tmp6, err := this.Levels()
	if err != nil {
		return 0, err
	}
	tmp7, err := this.SubBlocks()
	if err != nil {
		return 0, err
	}
	this.blockSize = int((1 << tmp6) * tmp7)
	return this.blockSize, nil
}
func (this *Acm) CompressedData() (v []byte, err error) {
	if (this._f_compressedData) {
		return this.compressedData, nil
	}
	this._f_compressedData = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(14), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp8, err := this._io.ReadBytesFull()
	if err != nil {
		return nil, err
	}
	tmp8 = tmp8
	this.compressedData = tmp8
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.compressedData, nil
}
func (this *Acm) Levels() (v int, err error) {
	if (this._f_levels) {
		return this.levels, nil
	}
	this._f_levels = true
	this.levels = int(this.SubbandParams & 15)
	return this.levels, nil
}
func (this *Acm) SubBlocks() (v int, err error) {
	if (this._f_subBlocks) {
		return this.subBlocks, nil
	}
	this._f_subBlocks = true
	this.subBlocks = int((this.SubbandParams >> 4) & 4095)
	return this.subBlocks, nil
}
